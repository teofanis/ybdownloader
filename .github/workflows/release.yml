name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true

env:
  GO_VERSION: '1.25'
  NODE_VERSION: '24'
  APP_NAME: 'ybdownloader'

permissions:
  contents: write

jobs:
  # Build Linux binaries
  build-linux:
    name: Build Linux
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Update wails.json version
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          VERSION_NUM="${VERSION#v}"  # Strip 'v' prefix if present
          jq --arg v "$VERSION_NUM" '.info.productVersion = $v' wails.json > wails.json.tmp
          mv wails.json.tmp wails.json

      - name: Build Linux amd64
        run: wails build -platform linux/amd64 -tags webkit2_41 -ldflags="-X main.Version=${{ steps.version.outputs.VERSION }}" -o ${{ env.APP_NAME }}-linux-amd64

      - name: Create Linux tarball package
        run: |
          cd build/bin
          chmod +x ${{ env.APP_NAME }}-linux-amd64
          # Create a directory with all needed files
          mkdir -p ${{ env.APP_NAME }}-linux-amd64-package
          cp ${{ env.APP_NAME }}-linux-amd64 ${{ env.APP_NAME }}-linux-amd64-package/
          cp ../linux/ybdownloader.desktop ${{ env.APP_NAME }}-linux-amd64-package/
          cp ../linux/install-protocol.sh ${{ env.APP_NAME }}-linux-amd64-package/
          cp ../appicon.png ${{ env.APP_NAME }}-linux-amd64-package/ybdownloader.png
          chmod +x ${{ env.APP_NAME }}-linux-amd64-package/install-protocol.sh
          # Create tarball
          tar -czvf ${{ env.APP_NAME }}-linux-amd64.tar.gz -C ${{ env.APP_NAME }}-linux-amd64-package .
          rm -rf ${{ env.APP_NAME }}-linux-amd64-package

      - name: Create AppImage
        run: |
          # Download appimagetool (Go/Wails binaries are self-contained, no need for linuxdeploy)
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage
          
          # Create AppDir structure
          mkdir -p AppDir/usr/bin
          mkdir -p AppDir/usr/share/applications
          mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
          
          # Copy binary
          cp build/bin/${{ env.APP_NAME }}-linux-amd64 AppDir/usr/bin/${{ env.APP_NAME }}
          chmod +x AppDir/usr/bin/${{ env.APP_NAME }}
          
          # Copy and update desktop file for AppImage (change Exec path)
          sed 's|/usr/bin/ybdownloader|ybdownloader|g' build/linux/ybdownloader.desktop > AppDir/usr/share/applications/ybdownloader.desktop
          cp AppDir/usr/share/applications/ybdownloader.desktop AppDir/ybdownloader.desktop
          
          # Copy icon
          cp build/appicon.png AppDir/usr/share/icons/hicolor/256x256/apps/ybdownloader.png
          cp build/appicon.png AppDir/ybdownloader.png
          ln -sf ybdownloader.png AppDir/.DirIcon
          
          # Create AppRun launcher script
          cat > AppDir/AppRun << 'EOF'
          #!/bin/bash
          SELF=$(readlink -f "$0")
          HERE=${SELF%/*}
          export PATH="${HERE}/usr/bin/:${PATH}"
          exec "${HERE}/usr/bin/ybdownloader" "$@"
          EOF
          chmod +x AppDir/AppRun
          
          # Create AppImage using appimagetool (--appimage-extract-and-run for CI without FUSE)
          ARCH=x86_64 ./appimagetool-x86_64.AppImage --appimage-extract-and-run AppDir ${{ env.APP_NAME }}-linux-amd64.AppImage
          
          # Move to build/bin
          mv ${{ env.APP_NAME }}-linux-amd64.AppImage build/bin/
          
          # Cleanup
          rm -rf AppDir appimagetool-x86_64.AppImage

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v6
        with:
          name: linux-builds
          path: |
            build/bin/*.tar.gz
            build/bin/*.AppImage
          retention-days: 1

  # Build Windows binaries (with optional signing)
  build-windows:
    name: Build Windows
    runs-on: windows-latest
    env:
      HAS_WINDOWS_CERT: ${{ secrets.WINDOWS_CERTIFICATE != '' }}
    steps:
      - uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install NSIS
        shell: powershell
        run: |
          Write-Host "Installing NSIS via Chocolatey..."
          choco install nsis -y --no-progress
          
          # Refresh environment to pick up new PATH entries from Chocolatey
          $env:Path = [System.Environment]::GetEnvironmentVariable("Path", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path", "User")
          
          # Add NSIS directories to GITHUB_PATH for subsequent steps
          $nsisDir = "C:\Program Files (x86)\NSIS"
          if (Test-Path $nsisDir) {
            Write-Host "Adding NSIS to GITHUB_PATH: $nsisDir"
            echo "$nsisDir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          }
          
          # Verify installation
          Write-Host "Verifying NSIS installation..."
          $nsisExe = "$nsisDir\makensis.exe"
          if (Test-Path $nsisExe) {
            Write-Host "NSIS installed at: $nsisExe"
            & $nsisExe /VERSION
          } else {
            Write-Error "NSIS installation failed - makensis.exe not found at $nsisExe"
            exit 1
          }

      - name: Get version
        id: version
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            echo "VERSION=${{ github.event.inputs.version }}" >> $env:GITHUB_OUTPUT
          } else {
            $version = "${{ github.ref }}" -replace "refs/tags/", ""
            echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          }

      - name: Update wails.json version
        shell: pwsh
        run: |
          $fullVersion = "${{ steps.version.outputs.VERSION }}"
          # Strip 'v' prefix for product version
          $version = $fullVersion -replace "^v", ""
          # Extract only the numeric version part for NSIS (e.g., "1.0.0" from "1.0.0-beta.1")
          # NSIS expects a version like "1.0.0" that becomes "1.0.0.0"
          $nsisVersion = $version -replace "-.*$", ""
          
          Write-Host "Full version: $fullVersion"
          Write-Host "Product version: $version"
          Write-Host "NSIS-compatible version: $nsisVersion"
          
          $json = Get-Content wails.json | ConvertFrom-Json
          $json.info.productVersion = $nsisVersion
          $json | ConvertTo-Json -Depth 10 | Set-Content wails.json
          
          Write-Host "Updated wails.json:"
          Get-Content wails.json

      - name: Verify NSIS in PATH
        shell: powershell
        run: |
          $nsis = Get-Command makensis -ErrorAction SilentlyContinue
          if ($nsis) {
            Write-Host "makensis available at: $($nsis.Source)"
            & makensis /VERSION
          } else {
            Write-Error "makensis not found in PATH!"
            exit 1
          }

      - name: Build Windows amd64
        shell: pwsh
        run: |
          Write-Host "Starting Wails build with NSIS..."
          wails build -platform windows/amd64 -nsis -ldflags="-X main.Version=${{ steps.version.outputs.VERSION }}" -v 2
          
          Write-Host "`nBuild completed. Checking output..."
          if (Test-Path "build/bin") {
            Get-ChildItem -Path build/bin -Recurse | Format-Table Name, Length, LastWriteTime
          } else {
            Write-Error "build/bin directory not found!"
            exit 1
          }

      - name: Rename binaries
        shell: pwsh
        run: |
          cd build/bin
          
          # Check for portable executable
          if (Test-Path "${{ env.APP_NAME }}.exe") {
            Rename-Item "${{ env.APP_NAME }}.exe" "${{ env.APP_NAME }}-windows-amd64.exe"
            Write-Host "Renamed portable executable"
          } else {
            Write-Error "Portable executable not found!"
            exit 1
          }
          
          # Check for NSIS installer
          if (Test-Path "${{ env.APP_NAME }}-amd64-installer.exe") {
            Rename-Item "${{ env.APP_NAME }}-amd64-installer.exe" "${{ env.APP_NAME }}-windows-amd64-installer.exe"
            Write-Host "Renamed NSIS installer"
          } else {
            Write-Error "NSIS installer not found! The -nsis build flag may have failed."
            Write-Host "Available files:"
            Get-ChildItem -Path . | Format-Table Name
            exit 1
          }

      # Sign Windows binaries using lando/code-sign-action (only if certificate is configured)
      - name: Sign Windows portable executable
        if: env.HAS_WINDOWS_CERT == 'true'
        uses: lando/code-sign-action@v3
        with:
          file: build/bin/${{ env.APP_NAME }}-windows-amd64.exe
          certificate-data: ${{ secrets.WINDOWS_CERTIFICATE }}
          certificate-password: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

      - name: Sign Windows installer
        if: env.HAS_WINDOWS_CERT == 'true'
        uses: lando/code-sign-action@v3
        with:
          file: build/bin/${{ env.APP_NAME }}-windows-amd64-installer.exe
          certificate-data: ${{ secrets.WINDOWS_CERTIFICATE }}
          certificate-password: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v6
        with:
          name: windows-builds
          path: build/bin/*.exe
          retention-days: 1

  # Build macOS binaries (universal binary with optional signing & notarization)
  build-macos:
    name: Build macOS
    runs-on: macos-latest
    env:
      HAS_APPLE_CERT: ${{ secrets.APPLE_CERTIFICATE != '' }}
      HAS_APPLE_NOTARY: ${{ secrets.APPLE_NOTARY_USER != '' }}
    steps:
      - uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Update wails.json version
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          VERSION_NUM="${VERSION#v}"  # Strip 'v' prefix if present
          jq --arg v "$VERSION_NUM" '.info.productVersion = $v' wails.json > wails.json.tmp
          mv wails.json.tmp wails.json

      - name: Build macOS (Universal)
        run: wails build -platform darwin/universal -ldflags="-X main.Version=${{ steps.version.outputs.VERSION }}"

      # Sign macOS app BEFORE creating DMG (critical!)
      # Without notarization (signing only)
      - name: Sign macOS app
        if: env.HAS_APPLE_CERT == 'true' && env.HAS_APPLE_NOTARY != 'true'
        uses: lando/code-sign-action@v3
        with:
          file: build/bin/${{ env.APP_NAME }}.app
          certificate-data: ${{ secrets.APPLE_CERTIFICATE }}
          certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          apple-team-id: ${{ secrets.APPLE_TEAM_ID }}
          options: --options runtime --entitlements build/darwin/entitlements.plist

      # Sign and notarize macOS app (full Apple Developer flow)
      - name: Sign and notarize macOS app
        if: env.HAS_APPLE_CERT == 'true' && env.HAS_APPLE_NOTARY == 'true'
        uses: lando/code-sign-action@v3
        with:
          file: build/bin/${{ env.APP_NAME }}.app
          certificate-data: ${{ secrets.APPLE_CERTIFICATE }}
          certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          apple-team-id: ${{ secrets.APPLE_TEAM_ID }}
          apple-notary-user: ${{ secrets.APPLE_NOTARY_USER }}
          apple-notary-password: ${{ secrets.APPLE_NOTARY_PASSWORD }}
          apple-product-id: com.ybdownloader.app
          options: --options runtime --entitlements build/darwin/entitlements.plist

      # Create DMG AFTER signing
      - name: Create DMG
        run: |
          cd build/bin
          if [ -d "${{ env.APP_NAME }}.app" ]; then
            hdiutil create -volname "${{ env.APP_NAME }}" \
              -srcfolder "${{ env.APP_NAME }}.app" \
              -ov -format UDZO \
              "${{ env.APP_NAME }}-macos-universal.dmg"
          fi

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v6
        with:
          name: macos-builds
          path: build/bin/*.dmg
          retention-days: 1

  # Create GitHub Release
  release:
    name: Create Release
    needs: [build-linux, build-windows, build-macos]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: dist
          merge-multiple: true

      - name: List downloaded files
        run: |
          echo "Downloaded artifacts:"
          find dist -type f -ls

      - name: Get version from tag
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        id: changelog
        run: |
          # Get commits since last tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" ${PREVIOUS_TAG}..HEAD | head -50)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" | head -50)
          fi
          
          # Use heredoc for multiline output
          {
            echo "CHANGELOG<<EOF"
            echo "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.VERSION }}
          name: YBDownloader ${{ steps.version.outputs.VERSION }}
          body: |
            ## What's Changed
            ${{ steps.changelog.outputs.CHANGELOG }}

            ## Downloads
            
            | Platform | Architecture | File | Description |
            |----------|-------------|------|-------------|
            | **Windows** | x64 | `${{ env.APP_NAME }}-windows-amd64-installer.exe` | Recommended installer |
            | **Windows** | x64 | `${{ env.APP_NAME }}-windows-amd64.exe` | Portable executable |
            | **macOS** | Universal (Intel + Apple Silicon) | `${{ env.APP_NAME }}-macos-universal.dmg` | Disk image |
            | **Linux** | x64 | `${{ env.APP_NAME }}-linux-amd64.AppImage` | AppImage (recommended) |
            | **Linux** | x64 | `${{ env.APP_NAME }}-linux-amd64.tar.gz` | Tarball |
            
            ## Installation Notes
            
            ### Windows
            - Download and run the installer, or use the portable `.exe` directly
            - You may see a SmartScreen warning - click "More info" → "Run anyway"
            - Deep links (`ybdownloader://`) are registered automatically by the installer
            
            ### macOS
            - Open the `.dmg` file and drag the app to Applications
            - First launch: Right-click → Open (to bypass Gatekeeper)
            - Deep links (`ybdownloader://`) are registered automatically
            
            ### Linux
            **AppImage (Recommended):**
            - Download the `.AppImage` file
            - Make it executable: `chmod +x ${{ env.APP_NAME }}-linux-amd64.AppImage`
            - Run it directly - no installation needed
            - For desktop integration (including deep links), use [AppImageLauncher](https://github.com/TheAssassin/AppImageLauncher)
            
            **Tarball:**
            - Extract: `tar -xzf ${{ env.APP_NAME }}-linux-amd64.tar.gz`
            - Run `./install-protocol.sh ./ybdownloader-linux-amd64` to register deep links
            - Requires GTK3 and WebKit2GTK 4.1
            
            ### FFmpeg
            FFmpeg is required for audio conversion. The app will prompt you to download it automatically if not found.
            
            ### Browser Extension
            Install the YBDownloader browser extension to add videos directly from YouTube with one click!
            
          files: |
            dist/*
          draft: false
          prerelease: ${{ contains(steps.version.outputs.VERSION, '-beta') || contains(steps.version.outputs.VERSION, '-alpha') || contains(steps.version.outputs.VERSION, '-rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
