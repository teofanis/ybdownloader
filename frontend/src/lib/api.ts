/**
 * API client for Wails bindings.
 * 
 * This module provides a typed wrapper around Wails-generated bindings,
 * ensuring all backend calls go through a single, testable interface.
 */

// These will be generated by Wails - import when available
// For now, we define the interface and will connect once bindings exist

import type {
  QueueItem,
  DownloadProgress,
  Settings,
  VideoMetadata,
  Format,
} from "@/types";

// Placeholder for Wails bindings until generated
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type WailsBinding = (...args: any[]) => Promise<any>;

// These will be replaced with actual imports once Go code is bound
let _addToQueue: WailsBinding | null = null;
let _removeFromQueue: WailsBinding | null = null;
let _getQueue: WailsBinding | null = null;
let _startDownload: WailsBinding | null = null;
let _startAllDownloads: WailsBinding | null = null;
let _cancelDownload: WailsBinding | null = null;
let _cancelAllDownloads: WailsBinding | null = null;
let _retryDownload: WailsBinding | null = null;
let _clearCompleted: WailsBinding | null = null;
let _fetchMetadata: WailsBinding | null = null;
let _getSettings: WailsBinding | null = null;
let _saveSettings: WailsBinding | null = null;
let _resetSettings: WailsBinding | null = null;
let _selectDirectory: WailsBinding | null = null;
let _openFile: WailsBinding | null = null;
let _openFolder: WailsBinding | null = null;

/**
 * Initialize API bindings from Wails.
 * Called once when App component mounts.
 */
export async function initializeBindings(): Promise<void> {
  try {
    // Dynamic import of Wails bindings - path is relative to this file
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const bindings = await (import("../../wailsjs/go/app/App") as Promise<any>);
    
    _addToQueue = bindings.AddToQueue;
    _removeFromQueue = bindings.RemoveFromQueue;
    _getQueue = bindings.GetQueue;
    _startDownload = bindings.StartDownload;
    _startAllDownloads = bindings.StartAllDownloads;
    _cancelDownload = bindings.CancelDownload;
    _cancelAllDownloads = bindings.CancelAllDownloads;
    _retryDownload = bindings.RetryDownload;
    _clearCompleted = bindings.ClearCompleted;
    _fetchMetadata = bindings.FetchMetadata;
    _getSettings = bindings.GetSettings;
    _saveSettings = bindings.SaveSettings;
    _resetSettings = bindings.ResetSettings;
    _selectDirectory = bindings.SelectDirectory;
    _openFile = bindings.OpenFile;
    _openFolder = bindings.OpenFolder;
  } catch (error) {
    console.warn("Wails bindings not available, running in dev mode:", error);
  }
}

// ============================================================================
// Queue Operations
// ============================================================================

export async function addToQueue(url: string, format: Format): Promise<QueueItem> {
  if (!_addToQueue) throw new Error("API not initialized");
  return _addToQueue(url, format);
}

export async function removeFromQueue(id: string): Promise<void> {
  if (!_removeFromQueue) throw new Error("API not initialized");
  return _removeFromQueue(id);
}

export async function getQueue(): Promise<QueueItem[]> {
  if (!_getQueue) throw new Error("API not initialized");
  return _getQueue();
}

export async function startDownload(id: string): Promise<void> {
  if (!_startDownload) throw new Error("API not initialized");
  return _startDownload(id);
}

export async function startAllDownloads(): Promise<void> {
  if (!_startAllDownloads) throw new Error("API not initialized");
  return _startAllDownloads();
}

export async function cancelDownload(id: string): Promise<void> {
  if (!_cancelDownload) throw new Error("API not initialized");
  return _cancelDownload(id);
}

export async function cancelAllDownloads(): Promise<void> {
  if (!_cancelAllDownloads) throw new Error("API not initialized");
  return _cancelAllDownloads();
}

export async function retryDownload(id: string): Promise<void> {
  if (!_retryDownload) throw new Error("API not initialized");
  return _retryDownload(id);
}

export async function clearCompleted(): Promise<void> {
  if (!_clearCompleted) throw new Error("API not initialized");
  return _clearCompleted();
}

// ============================================================================
// Metadata Operations
// ============================================================================

export async function fetchMetadata(url: string): Promise<VideoMetadata> {
  if (!_fetchMetadata) throw new Error("API not initialized");
  return _fetchMetadata(url);
}

// ============================================================================
// Settings Operations
// ============================================================================

export async function getSettings(): Promise<Settings> {
  if (!_getSettings) throw new Error("API not initialized");
  return _getSettings();
}

export async function saveSettings(settings: Settings): Promise<void> {
  if (!_saveSettings) throw new Error("API not initialized");
  return _saveSettings(settings);
}

export async function resetSettings(): Promise<Settings> {
  if (!_resetSettings) throw new Error("API not initialized");
  return _resetSettings();
}

// ============================================================================
// File Operations
// ============================================================================

export async function selectDirectory(): Promise<string | null> {
  if (!_selectDirectory) throw new Error("API not initialized");
  return _selectDirectory();
}

export async function openFile(path: string): Promise<void> {
  if (!_openFile) throw new Error("API not initialized");
  return _openFile(path);
}

export async function openFolder(path: string): Promise<void> {
  if (!_openFolder) throw new Error("API not initialized");
  return _openFolder(path);
}

// ============================================================================
// Event Types (for Wails runtime events)
// ============================================================================

export const Events = {
  DOWNLOAD_PROGRESS: "download:progress",
  DOWNLOAD_COMPLETE: "download:complete",
  DOWNLOAD_ERROR: "download:error",
  QUEUE_UPDATED: "queue:updated",
} as const;

export type EventName = (typeof Events)[keyof typeof Events];

export interface EventPayloads {
  [Events.DOWNLOAD_PROGRESS]: DownloadProgress;
  [Events.DOWNLOAD_COMPLETE]: { itemId: string; filePath: string };
  [Events.DOWNLOAD_ERROR]: { itemId: string; error: string };
  [Events.QUEUE_UPDATED]: QueueItem[];
}

